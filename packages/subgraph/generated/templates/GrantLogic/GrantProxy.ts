// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class GrantProxy extends ethereum.SmartContract {
  static bind(address: Address): GrantProxy {
    return new GrantProxy("GrantProxy", address);
  }

  category(): string {
    let result = super.call("category", "category():(string)", []);

    return result[0].toString();
  }

  try_category(): ethereum.CallResult<string> {
    let result = super.tryCall("category", "category():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  creator(): Address {
    let result = super.call("creator", "creator():(address)", []);

    return result[0].toAddress();
  }

  try_creator(): ethereum.CallResult<Address> {
    let result = super.tryCall("creator", "creator():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  deliverableFormat(): string {
    let result = super.call(
      "deliverableFormat",
      "deliverableFormat():(string)",
      []
    );

    return result[0].toString();
  }

  try_deliverableFormat(): ethereum.CallResult<string> {
    let result = super.tryCall(
      "deliverableFormat",
      "deliverableFormat():(string)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  description(): string {
    let result = super.call("description", "description():(string)", []);

    return result[0].toString();
  }

  try_description(): ethereum.CallResult<string> {
    let result = super.tryCall("description", "description():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  fundingState(): i32 {
    let result = super.call("fundingState", "fundingState():(uint8)", []);

    return result[0].toI32();
  }

  try_fundingState(): ethereum.CallResult<i32> {
    let result = super.tryCall("fundingState", "fundingState():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  genre(): string {
    let result = super.call("genre", "genre():(string)", []);

    return result[0].toString();
  }

  try_genre(): ethereum.CallResult<string> {
    let result = super.tryCall("genre", "genre():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  logicAddress(): Address {
    let result = super.call("logicAddress", "logicAddress():(address)", []);

    return result[0].toAddress();
  }

  try_logicAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall("logicAddress", "logicAddress():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  minFundingAmount(): BigInt {
    let result = super.call(
      "minFundingAmount",
      "minFundingAmount():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_minFundingAmount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minFundingAmount",
      "minFundingAmount():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  timeline(): i32 {
    let result = super.call("timeline", "timeline():(uint8)", []);

    return result[0].toI32();
  }

  try_timeline(): ethereum.CallResult<i32> {
    let result = super.tryCall("timeline", "timeline():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  title(): string {
    let result = super.call("title", "title():(string)", []);

    return result[0].toString();
  }

  try_title(): ethereum.CallResult<string> {
    let result = super.tryCall("title", "title():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _creator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _title(): string {
    return this._call.inputValues[1].value.toString();
  }

  get _description(): string {
    return this._call.inputValues[2].value.toString();
  }

  get _category(): string {
    return this._call.inputValues[3].value.toString();
  }

  get _genre(): string {
    return this._call.inputValues[4].value.toString();
  }

  get _timeline(): i32 {
    return this._call.inputValues[5].value.toI32();
  }

  get _minFundingAmount(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get _deliverableFormat(): string {
    return this._call.inputValues[7].value.toString();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class DefaultCall extends ethereum.Call {
  get inputs(): DefaultCall__Inputs {
    return new DefaultCall__Inputs(this);
  }

  get outputs(): DefaultCall__Outputs {
    return new DefaultCall__Outputs(this);
  }
}

export class DefaultCall__Inputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class DefaultCall__Outputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}
